# BugFix P0: 截断检测逻辑反转修复

**日期**: 2025-10-27  
**优先级**: P0 (Critical - 影响核心功能准确性)  
**影响范围**: 图片和表格的窗口评分机制  
**修复状态**: ✅ 已修复

---

## 🐛 问题描述

### 症状
边缘截断检测逻辑 (`detect_top_edge_truncation`) 被反转，导致：
- ✅ **完整窗口**（对象边缘与 clip 重合）被错误地识别为"截断"并扣分 0.15
- ❌ **真正的截断窗口**（对象延伸到 clip 外面）反而没有被检测到

结果：**截断的裁剪窗口得分高于完整窗口**，系统性地选择了错误的候选窗口。

---

## 📍 问题位置

### 影响函数（2 处）

1. **图片评分** - `detect_top_edge_truncation()`
   - 文件: `scripts/extract_pdf_assets.py`
   - 行号: Line 2336-2371（修复前）

2. **表格评分** - `detect_top_edge_truncation_table()`
   - 文件: `scripts/extract_pdf_assets.py`
   - 行号: Line 3622-3642（修复前）

---

## 🔍 根本原因分析

### 错误的逻辑（修复前）

#### Above 情况（图注在下方，图在上方）
```python
# ❌ 错误：检测对象顶部是否在 clip 顶部附近
if clip.y0 - 5 < obj.y0 < clip.y0 + edge_margin:
    if obj.height > min_obj_height:
        return True  # 误判为截断
```

**问题分析**:
- 如果 `obj.y0 ≈ clip.y0`（对象顶部与 clip 顶部重合），说明对象**完整在 clip 内**
- 但代码却认为这是"截断"，扣分 0.15
- 真正的截断是：`obj.y0 < clip.y0`（对象顶部在 clip 外面）

#### Below 情况（图注在上方，图在下方）
```python
# ❌ 错误：检测对象底部是否在 clip 底部附近
if clip.y1 - edge_margin < obj.y1 < clip.y1 + 5:
    if obj.height > min_obj_height:
        return True  # 误判为截断
```

**问题分析**:
- 如果 `obj.y1 ≈ clip.y1`（对象底部与 clip 底部重合），说明对象**完整在 clip 内**
- 但代码却认为这是"截断"，扣分 0.15
- 真正的截断是：`obj.y1 > clip.y1`（对象底部在 clip 外面）

---

### 正确的逻辑（修复后）

#### Above 情况
```python
# ✅ 正确：检测对象是否延伸到 clip 外面
if obj.y0 < clip.y0 and obj.y1 > clip.y0 + min_obj_height:
    return True  # 对象顶部被截断
```

**判断条件**:
1. `obj.y0 < clip.y0`: 对象顶部在 clip 外面（向上延伸）
2. `obj.y1 > clip.y0 + min_obj_height`: 对象底部在 clip 内足够深度（至少 50pt）

**含义**: 对象的顶部被 clip 的顶部边界截断了

#### Below 情况
```python
# ✅ 正确：检测对象是否延伸到 clip 外面
if obj.y1 > clip.y1 and obj.y0 < clip.y1 - min_obj_height:
    return True  # 对象底部被截断
```

**判断条件**:
1. `obj.y1 > clip.y1`: 对象底部在 clip 外面（向下延伸）
2. `obj.y0 < clip.y1 - min_obj_height`: 对象顶部在 clip 内足够深度（至少 50pt）

**含义**: 对象的底部被 clip 的底部边界截断了

---

## 🎯 修复方案

### 修复代码对比

#### 图片评分函数 (Line 2336)

**修复前**:
```python
def detect_top_edge_truncation(clip: fitz.Rect, objects: List[fitz.Rect], side: str) -> bool:
    edge_margin = 10.0
    min_obj_height = 50.0
    
    for obj in objects:
        if not (obj.x0 < clip.x1 and obj.x1 > clip.x0):
            continue
        
        if side == 'above':
            # ❌ 误判：对象在clip内也会被判定为截断
            if clip.y0 - 5 < obj.y0 < clip.y0 + edge_margin:
                if obj.height > min_obj_height:
                    return True
        else:  # below
            # ❌ 误判：对象在clip内也会被判定为截断
            if clip.y1 - edge_margin < obj.y1 < clip.y1 + 5:
                if obj.height > min_obj_height:
                    return True
    
    return False
```

**修复后**:
```python
def detect_top_edge_truncation(clip: fitz.Rect, objects: List[fitz.Rect], side: str) -> bool:
    """
    检测窗口边缘是否截断对象（方案B）
    
    修复说明（2025-10-27）:
        原逻辑反转：当对象边缘与clip重合时误判为截断，导致完整窗口被扣分
        正确逻辑：检测对象是否延伸到clip外面（被clip边界截断）
    """
    min_obj_height = 50.0  # 最小对象高度阈值（pt）
    
    for obj in objects:
        # 检查对象是否与窗口水平重叠
        if not (obj.x0 < clip.x1 and obj.x1 > clip.x0):
            continue
        
        if side == 'above':
            # ✅ 正确：对象顶部在clip外面 + 对象底部在clip内足够深度
            if obj.y0 < clip.y0 and obj.y1 > clip.y0 + min_obj_height:
                return True
        else:  # below
            # ✅ 正确：对象底部在clip外面 + 对象顶部在clip内足够深度
            if obj.y1 > clip.y1 and obj.y0 < clip.y1 - min_obj_height:
                return True
    
    return False
```

#### 表格评分函数 (Line 3622)

**修复前**:
```python
def detect_top_edge_truncation_table(clip: fitz.Rect, objects: List[fitz.Rect], side: str) -> bool:
    edge_margin = 10.0
    min_obj_height = 50.0
    for obj in objects:
        if not (obj.x0 < clip.x1 and obj.x1 > clip.x0):
            continue
        if side == 'above':
            # ❌ 误判
            if clip.y0 - 5 < obj.y0 < clip.y0 + edge_margin:
                if obj.height > min_obj_height:
                    return True
        else:  # below
            # ❌ 误判
            if clip.y1 - edge_margin < obj.y1 < clip.y1 + 5:
                if obj.height > min_obj_height:
                    return True
    return False
```

**修复后**:
```python
def detect_top_edge_truncation_table(clip: fitz.Rect, objects: List[fitz.Rect], side: str) -> bool:
    """
    检测表格窗口边缘是否截断对象
    
    修复说明（2025-10-27）:
        原逻辑反转：当对象边缘与clip重合时误判为截断，导致完整窗口被扣分
        正确逻辑：检测对象是否延伸到clip外面（被clip边界截断）
    """
    min_obj_height = 50.0
    for obj in objects:
        if not (obj.x0 < clip.x1 and obj.x1 > clip.x0):
            continue
        if side == 'above':
            # ✅ 正确
            if obj.y0 < clip.y0 and obj.y1 > clip.y0 + min_obj_height:
                return True
        else:  # below
            # ✅ 正确
            if obj.y1 > clip.y1 and obj.y0 < clip.y1 - min_obj_height:
                return True
    return False
```

---

## 📊 影响评估

### 影响范围

| 模块 | 影响 | 说明 |
|------|------|------|
| **图片提取** | ⚠️ 高 | 所有使用 Anchor V2 的图片提取都受影响 |
| **表格提取** | ⚠️ 高 | 所有使用 Anchor V2 的表格提取都受影响 |
| **单元测试** | ✅ 无 | 未有针对此函数的单元测试 |
| **已发布版本** | ⚠️ 中 | v2.0-v2.5 所有版本都存在此 bug |

### 预期改善

修复后，预期效果：
- ✅ **准确率提升**: +5-10%（完整窗口不再被错误惩罚）
- ✅ **截断率降低**: -15-20%（真正的截断窗口现在会被正确识别并扣分）
- ✅ **Fallback 率降低**: -8-12%（正确窗口得分更高，更容易通过验收）
- ✅ **用户体验**: 显著改善（减少图片被截不完整的情况）

---

## 🧪 验证方案

### 1. 单元测试（建议新增）

```python
def test_detect_top_edge_truncation():
    """测试截断检测逻辑"""
    # Above 情况：图在上方
    clip_above = fitz.Rect(100, 100, 500, 400)
    
    # 情况1：对象完整在 clip 内（obj.y0 == clip.y0）
    obj_complete = fitz.Rect(100, 100, 500, 350)
    assert not detect_top_edge_truncation(clip_above, [obj_complete], 'above')
    
    # 情况2：对象被截断（obj.y0 < clip.y0）
    obj_truncated = fitz.Rect(100, 50, 500, 200)
    assert detect_top_edge_truncation(clip_above, [obj_truncated], 'above')
    
    # Below 情况：图在下方
    clip_below = fitz.Rect(100, 200, 500, 600)
    
    # 情况3：对象完整在 clip 内（obj.y1 == clip.y1）
    obj_complete_below = fitz.Rect(100, 300, 500, 600)
    assert not detect_top_edge_truncation(clip_below, [obj_complete_below], 'below')
    
    # 情况4：对象被截断（obj.y1 > clip.y1）
    obj_truncated_below = fitz.Rect(100, 500, 500, 700)
    assert detect_top_edge_truncation(clip_below, [obj_truncated_below], 'below')
```

### 2. 回归测试

使用 `basic-benchmark` 中的 7 个 PDF 重新运行提取：

```bash
for pdf in tests/basic-benchmark/*/*.pdf; do
    echo "Testing: $pdf"
    python3 scripts/extract_pdf_assets.py \
        --pdf "$pdf" \
        --preset robust \
        --debug-visual
done
```

**检查要点**:
- ✅ 图片是否更完整（顶部/底部不再被误裁）
- ✅ Fallback 率是否降低
- ✅ Debug 可视化中，蓝色（Baseline）窗口是否更准确

### 3. 对比测试（修复前 vs 修复后）

| 指标 | 修复前 | 修复后 | 改善 |
|------|--------|--------|------|
| 准确率（完整提取） | 92.1% | **预期 95-97%** | +3-5% |
| 误裁率（截断） | 1.8% | **预期 <1%** | -50% |
| Fallback 率 | 18.6% | **预期 10-12%** | -35% |

---

## 📝 修复清单

- [x] 修复图片评分函数 `detect_top_edge_truncation()` (Line 2336)
- [x] 修复表格评分函数 `detect_top_edge_truncation_table()` (Line 3622)
- [x] 添加详细注释说明修复原因
- [x] 创建 bug 修复文档
- [ ] 添加单元测试（建议）
- [ ] 运行回归测试（建议）
- [ ] 更新技术总结文档

---

## 🎓 教训与改进

### 问题根源
1. **逻辑混淆**: 将"对象在clip附近"混淆为"对象被clip截断"
2. **测试不足**: 缺少针对边缘情况的单元测试
3. **代码审查**: 初始实现时未进行充分的边界条件分析

### 改进措施
1. ✅ **添加详细注释**: 在关键逻辑处说明判断条件的含义
2. ✅ **修复文档化**: 在代码中标注修复日期和原因
3. 🔄 **单元测试**: 为边缘检测逻辑添加单元测试（待实施）
4. 🔄 **代码审查**: 对类似的几何判断逻辑进行全面审查（待实施）

### 类似风险点（需排查）
- ⚠️ 其他几何边界判断逻辑（如 `snap_clip_edges()`, `_refine_clip_by_objects()`）
- ⚠️ 方向判断逻辑（如 `above` vs `below` 的处理）
- ⚠️ 坐标系统混淆（PDF 坐标原点在左下角，需注意 y 轴方向）

---

## 🔗 相关资源

- **修复 Commit**: 2025-10-27 P0 截断检测逻辑反转修复
- **相关 Issue**: 无（内部发现）
- **测试报告**: `docs/批量提取报告-20251027.md`（修复前基准数据）
- **技术文档**: `docs/main/PDF图表提取技术总结-20251027-v3.md`

---

**修复人员**: AI Assistant  
**审核人员**: 待定  
**修复日期**: 2025-10-27  
**文档版本**: v1.0

