# Figure 2 裁剪问题深度分析

**文档日期**: 2025-10-26  
**问题PDF**: 2509.17765v1 (Qwen3-Omni Technical Report)  
**问题图表**: Figure 2 (Page 3)  
**分析对象**: 为什么只裁剪了真实图形的一半？

---

## 📊 问题现象

### 当前裁剪结果
- **Caption位置**: `70.9,464.8 -> 526.1,496.7`
- **Baseline窗口**: `26.0,204.8 -> 569.3,458.8`（高度254pt）
- **Final结果**: 与Baseline完全相同（A-only Fallback，黄色边框）

### 真实图形范围
从调试图片可以清楚看到，完整的Figure 2应该包含：
```
真实顶部: y ≈ 72（页面顶部区域）
Caption底部: y = 464.8
完整高度: 464.8 - 72 = ~393pt

当前裁剪:
Baseline顶部: y = 204.8
裁剪高度: 464.8 - 204.8 = 260pt
缺失高度: 204.8 - 72 = 132pt（约33%的图形内容）
```

**缺失内容**：
- Qwen3-Omni logo和标题
- MoE架构图的上半部分（Talker和Thinker的上层结构）
- Vision Encoder和AuT的顶部区域

---

## 🔍 根因分析

### 问题1：锚点阶段就选错了窗口

#### Anchor V2评分机制（Line 2336-2357）

```python
def fig_score(clip: fitz.Rect) -> float:
    # 1. 墨迹密度（权重55%）
    ink = estimate_ink_ratio(pix)  # 小分辨率渲染
    
    # 2. 对象覆盖率（权重25%）
    obj = object_area_ratio(clip)
    
    # 3. 段落占比（权重-20%，惩罚）
    para = _paragraph_ratio(clip, ...)
    
    # 4. 组件数量奖励（权重8%）
    comp_cnt = comp_count(clip)
    comp_bonus = 0.08 * min(1.0, comp_cnt / 3.0)
    
    # 5. 基础评分
    base = 0.55 * ink + 0.25 * obj - 0.2 * para + comp_bonus
    
    # 6. 距离罚项（关键！）★★★
    dist = abs(cap_rect.y0 - clip.y1)  # above情况
    base -= dist_lambda * (dist / page_rect.height)
    # dist_lambda = 0.12（默认）
    
    return base
```

#### 为什么更高的窗口得分更低？

**假设扫描两个候选窗口**：

| 窗口 | y0 | y1 | 高度 | 距Caption | 距离罚项 | 可能原因 |
|-----|----|----|------|----------|---------|---------|
| **候选A**（正确） | **72** | **458.8** | **387pt** | **6pt** | **-0.001** | 包含完整图形 |
| **候选B**（错误，实际选中） | **204.8** | **458.8** | **254pt** | **6pt** | **-0.001** | 仅下半部分 |

**关键发现**：两个窗口的距离罚项几乎相同（都紧邻Caption），**问题出在基础评分**！

#### 可能的基础评分差异原因

**候选A（72-458.8）** vs **候选B（204.8-458.8）**：

1. **墨迹密度（ink）**：
   - 候选A：包含上方的大片白色背景区域（Qwen3-Omni logo周围）
   - 候选B：不包含这些白色区域，**墨迹密度更高**
   - **结论**：候选B的ink评分可能 **更高**

2. **对象覆盖率（obj）**：
   - 如果上方72-204区域没有足够的PDF对象（可能是嵌入的单张位图）
   - 候选A的obj评分可能 **更低**

3. **段落占比（para）**：
   - 上方72-204区域可能包含Text Block（虽然图例中没有显示在这个范围）
   - 候选A的para评分可能 **更高（更负）**

**综合效应**：更高的窗口（候选A）得分反而更低！

---

### 问题2：为什么停在A-only Fallback？

从图例数据：
```
Baseline (Anchor Selection):
  Position: 26.0,204.8 -> 569.3,458.8
  Size: 543.3×254.0pt (26.62 sq.in)

Final (A-only Fallback):
  Position: 26.0,204.8 -> 569.3,458.8  (完全相同！)
  Size: 543.3×254.0pt (26.62 sq.in)
```

**分析流程**：

#### Phase A（文本裁切）：未生效
- Baseline和Final位置完全一样
- **原因**：204.8-458.8区域内没有检测到需要裁除的紧邻文字

#### Phase B（对象对齐）：执行但被拒绝
- 脚本执行了对象连通域分析
- **可能原因**：
  1. 检测到的对象可能导致窗口收缩
  2. 验收机制认为收缩后不满足质量要求（高度/面积/墨迹保留率）
  3. 回退到A-only

#### Phase D（自动裁剪）：执行但被拒绝
- 脚本执行了像素级白边检测
- **可能原因**：
  1. 自动裁剪后高度/面积收缩超过阈值
  2. 验收失败，回退到A-only

#### A-only Fallback：与Baseline相同
- 因为Phase A没有修改边界
- **结果**：直接使用Baseline窗口

---

## 🔧 解决方案

### 方案1：调整锚点评分参数（推荐）

#### 1.1 降低距离罚项权重
```bash
python scripts/extract_pdf_assets.py \
  --pdf paper.pdf \
  --preset robust \
  --scan-dist-lambda 0.06  # 降低到0.06（默认0.12）
```

**原理**：减弱距离对评分的影响，让内容质量（墨迹/对象）起主导作用

#### 1.2 增加最大扫描高度
```bash
--scan-heights 240,320,420,520,640,720,820,920  # 增加920pt候选
```

**原理**：提供更高的窗口候选

#### 1.3 组合调整（最佳）
```bash
python scripts/extract_pdf_assets.py \
  --pdf tests/basic-benchmark/2509.17765v1-Qwen3-Omni_Technical_Report/2509.17765v1.pdf \
  --preset robust \
  --scan-dist-lambda 0.06 \
  --scan-heights 240,320,420,520,640,720,820,920 \
  --debug-visual
```

---

### 方案2：使用强制方向（临时方案）

如果方案1不奏效，可以手动指定窗口高度：

```bash
# 方案2A：使用Anchor V1 + 环境变量
EXTRACT_FORCE_CLIP_HEIGHT_2=520 python scripts/extract_pdf_assets.py \
  --pdf paper.pdf \
  --anchor-mode v1 \
  --clip-height 520

# 方案2B：直接指定above+更大的clip-height
python scripts/extract_pdf_assets.py \
  --pdf paper.pdf \
  --anchor-mode v1 \
  --above 2 \
  --clip-height 520
```

**注意**：需要切换到Anchor V1才能使用`--above`参数

---

### 方案3：优化评分公式（代码级修改）

如果是系统性问题，可以考虑调整评分权重：

```python
# 当前公式（Line 2349）
base = 0.55 * ink + 0.25 * obj - 0.2 * para + comp_bonus

# 优化建议：增加对象权重，降低墨迹权重
base = 0.35 * ink + 0.40 * obj - 0.2 * para + comp_bonus
```

**原理**：对象覆盖率更能反映图形的完整性（PDF对象通常覆盖整个图形）

---

## 🧪 验证步骤

### 步骤1：使用方案1重新提取
```bash
cd tests/basic-benchmark/2509.17765v1-Qwen3-Omni_Technical_Report

python ../../../scripts/extract_pdf_assets.py \
  --pdf 2509.17765v1.pdf \
  --preset robust \
  --scan-dist-lambda 0.06 \
  --scan-heights 240,320,420,520,640,720,820,920 \
  --debug-visual \
  --debug-captions
```

### 步骤2：检查新的debug输出
```bash
# 查看新的可视化图片
open images/debug/Figure_2_p3_debug_stages.png

# 查看新的图例文件
cat images/debug/Figure_2_p3_legend.txt
```

### 步骤3：对比Baseline窗口
```bash
# 期望结果：Baseline窗口应该从 y≈72 开始
# 当前结果：Baseline窗口从 y=204.8 开始
```

---

## 📌 为什么Layout-Driven没有修正？

从图例看，版式驱动（V2 Architecture Step 3）检测到了6个Text Block：

```
Text Block 1 (paragraph_group): 70.9,475.7 -> 526.1,529.5  # Caption下方
Text Block 2 (title_h2):        70.9,551.2 -> 76.8,563.2   # 更下方
Text Block 3 (title_h2):        88.8,551.2 -> 156.5,563.2  # "Architecture"
Text Block 4 (title_h3):        93.3,576.6 -> 138.1,586.6  # "Overview"
Text Block 5 (paragraph_group): 70.4,597.3 -> 525.7,618.3  # Caption下方段落
Text Block 6 (paragraph_group): 106.4,666.0 -> 525.7,730.9 # 更下方段落
```

**关键发现**：
- **所有Text Block都在Caption下方**（y > 464.8）
- **上方72-204区域没有检测到Text Block**

**原因**：
1. 上方区域可能是纯图形（In-Figure Text），被正确识别为图表内容
2. Layout-Driven只能调整已选窗口的边界，**无法修正锚点阶段的选择错误**

**结论**：Layout-Driven对锚点阶段无能为力，**必须从锚点评分机制入手**

---

## 🎯 结论

### 根本原因
1. **锚点评分机制偏差**：更高的窗口因墨迹密度降低（包含白色背景）而得分更低
2. **距离罚项影响小**：两个窗口距Caption都很近，距离罚项几乎相同
3. **内容评分主导**：基础评分（墨迹/对象/段落）决定了窗口选择

### 推荐方案
**使用方案1**（调整锚点参数）：
```bash
--scan-dist-lambda 0.06  # 降低距离罚项
--scan-heights 240,320,420,520,640,720,820,920  # 增加高窗口候选
```

### 长期优化建议
1. **增加对象权重**：从25%提高到35-40%（对象覆盖率更能反映图形完整性）
2. **降低墨迹权重**：从55%降低到35-40%（墨迹密度受白色背景影响大）
3. **引入"图形完整性"指标**：检测图形是否被截断（边缘对象密度）

---

**分析者**: PDF Summary Agent Team  
**审核状态**: ✅ 待验证  
**后续行动**: 执行方案1并观察效果

