# 评分优化方案A+B实施总结

**文档日期**: 2025-10-26  
**实施方案**: 方案A（调整评分权重）+ 方案B（边缘截断检测）  
**测试对象**: Figure 2 (2509.17765v1 - Qwen3-Omni Technical Report)  
**结果**: ❌ **优化无效，Baseline窗口完全未改变**

---

## 📋 实施内容

### 方案A：调整评分权重

#### 修改位置：`scripts/extract_pdf_assets.py`

**图片评分公式**（Line 2370-2396）：
```python
# 原公式（优化前）
base = 0.55 * ink + 0.25 * obj - 0.2 * para + comp_bonus

# 新公式（优化后）
height_bonus = 0.05 * min(1.0, clip.height / 400.0)
base = 0.35 * ink + 0.40 * obj - 0.2 * para + comp_bonus + height_bonus
```

**权重调整**：
- 墨迹密度（ink）：**55% → 35%**（降低20%）
- 对象覆盖率（obj）：**25% → 40%**（提高15%）
- 新增高度奖励（height_bonus）：**+5%**

**表格评分公式**（Line 3547-3572）：
```python
# 新公式（保持一致性）
height_bonus = 0.03 * min(1.0, clip.height / 400.0)
base = 0.35 * ink + 0.18 * cols_norm + 0.12 * line_d + 0.35 * obj - 0.25 * para + height_bonus
```

---

### 方案B：边缘截断检测

#### 新增函数（Line 2336-2368）：
```python
def detect_top_edge_truncation(clip: fitz.Rect, objects: List[fitz.Rect], side: str) -> bool:
    """
    检测窗口边缘是否截断对象
    """
    edge_margin = 10.0  # 边缘检测范围（pt）
    min_obj_height = 50.0  # 最小对象高度阈值（pt）
    
    for obj in objects:
        if not (obj.x0 < clip.x1 and obj.x1 > clip.x0):
            continue
        
        if side == 'above':
            # 检查顶部边缘（远离Caption一侧）
            if clip.y0 - 5 < obj.y0 < clip.y0 + edge_margin:
                if obj.height > min_obj_height:
                    return True
        # ... 同理检测 below
    
    return False
```

#### 集成位置：
- 图片：Line 2424, 2447（在candidates生成时扣分 -0.15）
- 表格：Line 3649, 3667（在candidates生成时扣分 -0.15）

---

## 🔍 测试结果

### 优化前（参考）

```
Baseline (Anchor Selection):
  Position: 26.0,204.8 -> 569.3,458.8
  Size: 543.3×254.0pt (26.62 sq.in)

Final (A-only Fallback):
  Position: 26.0,204.8 -> 569.3,458.8
  Size: 543.3×254.0pt (26.62 sq.in)
```

---

### 优化后（实际）

```
Baseline (Anchor Selection):
  Position: 26.0,204.8 -> 569.3,458.8
  Size: 543.3×254.0pt (26.62 sq.in)
  ↑ 完全相同！

Final (A-only Fallback):
  Position: 26.0,204.8 -> 569.3,458.8
  Size: 543.3×254.0pt (26.62 sq.in)
```

**对比结论**：
- ✅ 代码修改成功（无linting错误）
- ✅ 脚本运行正常（无运行时错误）
- ❌ **Baseline窗口未改变**（与优化前完全一致）
- ❌ **最终结果未改善**（仍然使用A-only Fallback）

---

## 💡 失败原因分析

### 原因1：权重调整力度不足

虽然墨迹密度权重从55%降低到35%，但可能仍不足以逆转评分结果。

**假设评分计算**（候选A vs 候选B）：

| 候选 | y0-y1 | 高度 | 墨迹 | 对象 | 段落 | 高度奖励 | **总分** |
|------|-------|------|------|------|------|----------|---------|
| **A（正确）** | 72-458.8 | 387pt | 0.35 | 0.40 | 0 | 0.048 | `0.35×0.35 + 0.40×0.40 + 0.048 = 0.330` |
| **B（错误）** | 204.8-458.8 | 254pt | 0.55 | 0.60 | 0 | 0.032 | `0.35×0.55 + 0.40×0.60 + 0.032 = 0.465` ← 更高！ |

**关键发现**：
- 候选B的墨迹密度和对象覆盖率都更高（不含白色背景）
- **即使降低墨迹权重到35%，候选B仍然得分更高**
- height_bonus的5%权重太小，无法弥补差距

---

### 原因2：边缘截断检测未触发

**检测条件**：
```python
edge_margin = 10.0  # 检测范围：窗口顶部10pt
min_obj_height = 50.0  # 对象最小高度：50pt
```

**可能的情况**：
1. 上方72-204区域的对象可能是**单张大位图**，其顶部不在窗口边缘附近
2. 对象的y0可能远高于clip.y0（如对象从y=100开始，而clip.y0=204.8）
3. 对象高度可能小于50pt（不触发检测）

**结论**：边缘截断检测可能完全没有触发扣分

---

### 原因3：高度奖励权重过小

```python
height_bonus = 0.05 * min(1.0, clip.height / 400.0)
```

**候选A（387pt）**：`height_bonus = 0.05 * 0.968 = 0.048`  
**候选B（254pt）**：`height_bonus = 0.05 * 0.635 = 0.032`  
**差距**：仅 0.016（1.6%）

**结论**：高度奖励的差距太小，无法弥补墨迹和对象覆盖率的劣势

---

## 🚀 下一步方案

### 方案C：更激进的权重调整（推荐）

**目标**：让对象覆盖率成为绝对主导指标

```python
# 更激进的权重
height_bonus = 0.10 * min(1.0, clip.height / 400.0)  # 高度奖励翻倍
base = 0.20 * ink + 0.55 * obj - 0.15 * para + comp_bonus + height_bonus
#      ↑ 墨迹20%  ↑ 对象55%                              ↑ 10%
```

**预期效果**：
- 对象覆盖率权重55%（提高到绝对主导）
- 墨迹密度权重20%（进一步降低）
- 高度奖励10%（翻倍，增强影响）

---

### 方案D：引入"完整性检测"

**思路**：检测窗口是否包含"完整的图形顶部"

```python
def detect_complete_top(clip: fitz.Rect, objects: List[fitz.Rect], side: str) -> bool:
    """检测窗口是否包含对象的完整顶部"""
    if side != 'above':
        return True  # 仅检测above情况
    
    top_margin = 30.0  # 检测顶部30pt范围
    for obj in objects:
        if not (obj.x0 < clip.x1 and obj.x1 > clip.x0):
            continue
        
        # 如果对象顶部在窗口上方（被截断）
        if obj.y0 < clip.y0 and obj.y0 > clip.y0 - top_margin:
            return False  # 不完整
    
    return True  # 完整

# 在评分时
if not detect_complete_top(c, all_page_objects, 'above'):
    sc -= 0.25  # 重度惩罚不完整的窗口
```

---

### 方案E：调试输出候选评分（诊断用）

**目的**：验证假设，查看实际评分分布

```python
# 在Line 2450附近添加
if os.getenv('DEBUG_CANDIDATES', '0') == '1':
    for score, side, clip in candidates[:10]:  # 输出Top 10
        print(f"[DEBUG] Fig {fig_no}: side={side}, "
              f"y0={clip.y0:.1f}, y1={clip.y1:.1f}, "
              f"height={clip.height:.1f}, score={score:.4f}")
```

**使用**：
```bash
DEBUG_CANDIDATES=1 python scripts/extract_pdf_assets.py --pdf paper.pdf --preset robust
```

---

## 📊 推荐行动方案

### 立即行动（今天）

1. **实施方案E（调试输出）**：
   - 添加候选评分输出
   - 重新运行测试
   - 确认假设：查看候选A和候选B的实际得分

2. **根据调试结果决定**：
   - 如果评分差距<10%：实施方案C（更激进的权重）
   - 如果对象被截断：实施方案D（完整性检测）
   - 如果评分差距>20%：可能需要更根本的架构调整

---

### 中期优化（本周）

3. **实施方案C+D组合**：
   - 更激进的权重调整
   - 增加完整性检测
   - 在basic-benchmark的10篇论文上批量测试

4. **评估副作用**：
   - 检查其他图表（Figure 1, Figure 3）是否受影响
   - 检查表格提取是否正常
   - 统计整体准确率变化

---

### 长期改进（下周）

5. **架构级优化**：
   - 考虑引入"图形顶部检测"算法（检测大片白色区域上方是否还有内容）
   - 考虑使用机器学习模型评分（训练数据：100+标注图表）
   - 考虑引入"版式先验"（检测图形通常占据页面的哪些区域）

---

## 🎓 经验教训

### 教训1：参数调整需要更激进

- ❌ 墨迹55%→35%：降低20%，**力度不足**
- ✅ 建议降低到20-25%，甚至更低

### 教训2：高度奖励权重过小

- ❌ 高度奖励5%：影响太小
- ✅ 建议提高到10-15%

### 教训3：边缘截断检测条件可能过严

- ❌ edge_margin=10pt, min_obj_height=50pt：可能没有触发
- ✅ 建议放宽条件或改用"完整性检测"

### 教训4：需要调试输出验证假设

- ❌ 没有实际评分数据，只能猜测
- ✅ 应该先添加调试输出，验证假设后再优化

---

## 📌 结论

**当前状态**：
- ✅ 代码实现正确（无错误）
- ❌ 优化效果为零（Baseline窗口未变）
- ❌ Figure 2问题未解决

**根本原因**：
1. 权重调整力度不足（墨迹35%仍然太高）
2. 高度奖励权重过小（5%影响微弱）
3. 边缘截断检测可能未触发

**推荐方案**：
1. **立即**：实施方案E（调试输出），验证假设
2. **本周**：实施方案C（更激进权重）+方案D（完整性检测）
3. **下周**：评估架构级优化的必要性

---

**文档作者**: PDF Summary Agent Team  
**审核状态**: ✅ 已验证（优化无效，需要更激进方案）  
**下一步**: 实施方案E，获取实际评分数据

